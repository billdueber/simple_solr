require 'nokogiri'

class SimpleSolr::Schema
  # A simplistic representation of a schema

  module Matcher
    def derive_matcher(src)
      if src =~ /\A\*(.*)/
        Regexp.new("\\A(.*)(#{Regexp.escape($1)})\\Z")
      else
        src
      end
    end

    def matches(s)
      @matcher === s
    end


  end

  attr_reader :xmldoc

  def initialize(core)
    @core           = core
    @fields         = {}
    @dynamic_fields = {}
    @copy_fields    = Hash.new { |h, k| h[k] = [] }
    @field_types    = {}
    self.load
  end


  def fields
    @fields.values
  end

  def field(n)
    @fields[n]
  end

  def dynamic_field(n)
    @dynamic_fields[n]
  end

  def copy_fields_for(n)
    @copy_fields[n]
  end

  def dynamic_fields
    @dynamic_fields.values
  end

  def copy_fields
    @copy_fields.values.flatten
  end

  def add_field(f)
    @fields[f.name] = f
  end


  def fieldTypes
    @fieldTypes.values
  end

  def fieldType(k)
    @fieldTypes[k]
  end

  # When we add dynamic fields, we need to keep them sorted by
  # lenght of the key, since that's how they match
  def add_dynamic_field(f)
    raise "Dynamic field should be dynamic and have a '*' in it somewhere; '#{f.name}' does not" unless f.name =~ /\*/
    @dynamic_fields[f.name] = f

    @dynamic_fields         = @dynamic_fields.sort { |a, b| b[0].size <=> a[0].size }.to_h

  end

  def add_copy_field(f)
    cf = @copy_fields[f.source]
    cf << f
  end


  # For loading, we get the information about the fields via the API,
  # but grab an XML document for modifying/writing
  def load
    @xmldoc = Nokogiri.XML(@core.raw_get_content('admin/file', {:file => 'schema.xml'}))  do |config|
      config.noent # allow parsing of external entitity definitions
    end
    load_explicit_fields
    load_dynamic_fields
    load_copy_fields
  end


  def load_explicit_fields
    @fields = {}
    @core.get('schema/fields')['fields'].each do |field_hash|
      add_field(Field.new_from_solr_hash(field_hash))
    end
  end

  def load_dynamic_fields
    @dynamic_fields = {}
    @core.get('schema/dynamicfields')['dynamicFields'].each do |field_hash|
      f = DynamicField.new_from_solr_hash(field_hash)
      if @dynamic_fields[f.name]
        raise "Dynamic field '#{f.name}' defined more than once"
      end
      add_dynamic_field(f)
    end
  end

  def load_copy_fields
    @copy_fields = Hash.new { |h, k| h[k] = [] }
    @core.get('schema/copyfields')['copyFields'].each do |cfield_hash|
      add_copy_field(CopyField.new(cfield_hash['source'], cfield_hash['dest']))
    end
  end


  def write

  end

  def reload
    write
    @core.reload
  end


  # Figuring out which fields are actually produced can be hard:
  #   * If a non-dynamic field name matches, no dynamic_fields will match
  #   * The result of a copyField may match another dynamicField, but the
  #     result of *that* will not match more copyFields
  #   * dynamicFields are matched longest to shortest
  #
  # Suppose I have the following:
  #  dynamic *_ts => string
  #  dynamic *_t  => string
  #  dynamic *_s  => string
  #  dynamic *_ddd => string
  #
  #  copy    *_ts => *_t
  #  copy    *_ts => *_s
  #  copy    *_s  => *_ddd
  #
  # You might expect:
  #  name_ts => string
  #  name_ts copied to name_t => string
  #  name_ts copied to name_s => string
  #  name_s  copied to name_ddd => string
  #
  # ...giving us name_ts, name_t, name_s, and name_ddd
  #
  # What you'll find is that we don't get name_ddd, since
  # name_s was generated by a wildcard-enabled copyField
  # and that's where things stop.
  #
  # However, if you explicitly add a field called
  # name_s, it *will* get copied to name_ddd.
  #
  # Yeah. It's confusing.


  def first_matching_field(str)
    f = fields.find { |x| x.matches str } or first_matching_dfield(str)
  end

  def first_matching_dfield(str)
    df = dynamic_fields.find { |x| x.matches str }
    if df
      f        = Field.new(df.to_h)
      f[:name] = df.dynamic_name str
    end
    f

  end

  def resulting_fields(str)
    rv = []
    f  = first_matching_field(str)
    rv << f
    copy_fields.each do |cf|
      if cf.matches(f.name)
        dname      = cf.dynamic_name(f.name)
        fmf        = Field.new(first_matching_field(dname).to_h)
        fmf[:name] = dname
        rv << fmf
      end
    end
    rv.uniq
  end


  # A field, and some of its info
  # Use a struct because it'll make it easier to
  # set things programmatically.

  class Field_or_Type
    attr_accessor :name,
                  :type_name,
                  :indexed,
                  :stored,
                  :multi,
                  :sort_missing_last


    TEXT_ATTR_MAP = {
        :name      => 'name',
        :type_name => 'type',
    }

    BOOL_ATTR_MAP = {
        :stored            => 'stored',
        :indexed           => 'indexed',
        :multi             => 'multiValued',
        :sort_missing_last => 'sortMissingLast'
    }


    def ==(other)
      if other.respond_to? :name
        name == other.name
      else
        name == other
      end
    end


    def self.new_from_solr_hash(h)
      f = self.new

      TEXT_ATTR_MAP.each_pair do |field, xmlattr|
        f[field] = h[xmlattr]
      end
      BOOL_ATTR_MAP.each_pair do |field, xmlattr|
        f[field] = h[xmlattr]
      end

      # Set the name "manually" to force the
      # matcher
      f.name = h['name']

      f
    end

    def [](k)
      self.send(k.to_sym)
    end

    def []=(k, v)
      self.send("#{k}=".to_sym, v)
    end



    def to_h
      h = {}
      instance_variables.each do |iv|
        h[iv.to_s.sub('@', '')] = instance_variable_get(iv)
      end
      h
    end

    def initialize(h={})
      h.each_pair do |k, v|
        begin
          self[k] = v
        rescue
        end

      end
    end


    def stored?
      stored
    end

  end


  class Field < Field_or_Type
    include Matcher

    attr_accessor :type_name
    attr_reader :matcher

    def initialize(*args)
      super
      @dynamic = false
      @copy_to = []
    end


    def stored?
      defined? stored ? stored : type.stored?
    end


    def name=(n)
      @name    = n
      @matcher = derive_matcher(n)
    end


    def to_oga_node
      e      = Oga::XML::Element.new
      e.name = 'field'
      TEXT_ATTR_MAP.each_pair do |field, xmlattr|
        e.set(xmlattr, self[field]) unless self[field].nil?
      end
      BOOL_ATTR_MAP.each_pair do |field, xmlattr|
        e.set(xmlattr, self[field].to_s) unless self[field].nil?
      end
      e
    end
  end


  class DynamicField < Field

    def initialize(*args)
      super
      @dynamic = true
    end

    # What name will we get from a matching thing?
    def dynamic_name(s)
      m = @matcher.match(s)
      if m
        m[1] << m[2]
      end
    end


    # Dynamic fields are basically the same as regular fields,
    # but with a different tag

    def to_oga_node
      e      = super
      e.name = 'dynamicField'
      e
    end

  end


  # A basic field type
  #
  # We don't even try to represent the analysis chain; just store the raw
  # xml
  class FieldType < Field_or_Type
    attr_accessor :xml, :class

    def initialize(*args)
      super
      @xml = nil
    end
  end

  class CopyField
    include Matcher

    attr_accessor :source, :dest

    def initialize(source, dest)
      self.source   = source
      @dest         = dest
      @matcher      = derive_matcher(source)
      @dest_matcher = derive_matcher(dest)
    end

    # What name will we get from a matching thing?
    def dynamic_name(s)
      return @dest unless @dest =~ /\*/

      m = @matcher.match(s)
      if m
        prefix = m[1]
        return @dest.sub(/\*/, prefix)
      end
      nil

    end

    def source=(s)
      @matcher = derive_matcher(s)
      @source  = s
    end


  end


end

